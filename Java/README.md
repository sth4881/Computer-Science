# ☕ Java

## 📕 About Java
### Java
- **장점**
  - **모듈화**, **캡슐화**로 인해 코드 재사용성이 높고 유지보수가 용이하다.
    - 내용이 바뀐 클래스만 수정하면 되므로 전체 애플리케이션을 다시 컴파일하지 않아도 된다.
  - **이식성이 높은 언어이다.**
    - 이식성이란 다른 실행 환경을 가진 시스템 간에 프로그램을 옮겨 실행할 수 있는 것을 말한다.
    - 특정 운영체제에 종속되지 않기 때문에 소스 코드를 수정하지 않아도 `JRE`가 설치돼있는 모든 운영체제에서 실행할 수 있다.
  - **메모리를 자동으로 관리해준다.**
    - 자바가 직접 메모리를 관리해주기 때문에 개발자는 오로지 비즈니스 로직 코드 작성에만 집중할 수 있다.
    - 객체 생성 시 자동으로 메모리 영역을 찾아서 할당하고, 사용이 끝나면 `Garbage Collector`를 실행시켜서 자동으로 사용하지 않는 객체를 제거한다.
  - **멀티 스레드를 쉽게 구현할 수 있다.**
    - 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하기 때문에 실행되는 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있다.
  - **동적 로딩을 지원한다.**
    - 애플리케이션이 실행될 때 모든 객체를 생성하지 않고, 객체가 필요한 시점에 클래스를 동적 로딩해서 객체를 생성한다.
    - 또한, 개발이 끝난 후에 유지보수가 발생하더라도 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일하지 않아도 된다.
- **단점**
  - 다른 프로그래밍 언어와 비교해서 상대적으로 처리 속도가 느리다.
    - JVM을 통해서 기계어로 번역되고 실행하는 과정에서 시간이 소요된다.
    - 따라서 자바는 컴파일 단계에서 기계어를 바로 만들어주는 `C/C++` 보다 속도가 느리다.
  - 프로그램에 사용되는 객체가 많을 수록 용량이 커지고 많은 메모리를 사용한다.

### OOP (Object Oriented Programming)
- **개념**
  - 객체 지향 프로그래밍이란, 프로그래밍에서 필요한 데이터를 추상화해서 상태와 행위를 가진 객체를 만들고, 객체들 간에 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법을 말한다
- **OOP의 4가지 특징**
  - **상속 (Inheritance)**
    - 부모 클래스의 필드와 메소드를 그대로 이어받아 사용할 수 있는 특징이다.
    - 기능의 일부분을 변경해야하는 경우, 상속받은 자식 클래스에서 해당 기능만 다시 정의하여 사용할 수 있다.
    - 하위 객체는 상위 객체를 재사용하여 쉽고 빠르게 설계할 수 있기 때문에 **반복되는 코드의 중복을 줄일 수 있다.**
    - 클래스와 상속 관계에서 혼란을 줄 수 있기 때문에 **다중 상속은 불가능**하며, 필요에 따라 인터페이스를 사용할 수 있도록 하였다.
  - **추상화 (Abstraction)**
    - 여러 객체들 간에 공통으로 사용되는 핵심 개념 또는 기능을 추출하여 하위 시스템과 분리하는 방법을 말한다.
  - **캡슐화 (Encapsulation)**
    - 외부에서 내부 구조를 알지 못하도록 **정보은닉**을 통해 데이터의 구조와 역할, 기능 등을 하나의 캡슐 형태로 만드는 방법이다.
    - 외부에서의 잘못된 사용으로 인해 객체가 손상되지 않도록 막고, 불필요한 내용이 외부에 공개되는 것을 방지하기 위해서 사용한다.
    - 자바에서는 `private` 접근제한자로 필드를 선언해서 데이터를 보호하고, `Getter` 또는 `Setter` 메소드를 통해서만 내부를 접근할 수 있도록 한다.
  - **다형성 (Polymorphism)**
    - **개념**
      - 하나의 객체에 여러 가지 타입을 대입하여 다양한 기능을 이용할 수 있도록 하는 성질이다.
      - 자식 클래스가 부모 클래스의 메소드를 오버라이딩해서 역할에 맞게 활용할 수 있는 특징이다.
      - 부모 타입에는 모든 자식 객체를 대입할 수 있으며, 인터페이스 타입에는 모든 구현 객체를 대입할 수 있다.
    - **Overriding**
      - 자식 클래스가 부모 클래스를 상속받거나 인터페이스를 구현할 때, 상위 클래스 또는 인터페이스에 정의되어 있는 메소드를 하위 클래스에서 재정의해서 사용하는 방법이다.
      - 오버라이딩하려는 메소드는 상위 클래스의 메소드명과 매개변수, 반환형이 모두 같아야만 한다.
      - 메소드를 호출할 때 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다.
    - **Overloading**
      - 하나의 메소드로 매개변수 타입과 개수에 따라서 여러 가지의 기능들을 수행할 수 있도록 하는 방법이다.
      - 오버로딩을 하기 위해서는 메소드명은 같고, 매개변수의 타입 또는 개수가 달라야만 한다.
      - 오버로딩을 통해서 코드의 중복을 줄이고 가독성을 향상시킬 수 있다.
- **절차적 프로그래밍 (Procedural Programming)**
  - **개념**
    - 개체를 순차적으로 처리하며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다.
  - **장점**
    - 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체 지향 언어에 비해 처리속도가 빠르다.
  - **단점**
    - 유지보수가 어렵다.
      - 모든 구성요소가 유기적으로 연결돼있어서 시스템의 일부분에 문제가 발생해도 전체에 영향을 미친다.
      - 특히 프로그램에서 발생한 문제를 찾아내서 고치는 디버깅 과정이 어렵다.
    - 생산 효율이 나쁘다.
      - 실행 순서가 정해져 있으므로 코드의 순서가 바뀌면 결과가 달라질 가능성이 높다.

### SOLID - 객체 지향 프로그래밍의 5대 설계 원칙
- **SRP (Single Responsibility Principle) : 단일 책임 원칙**
  - `모든 클래스는 각각 하나의 책임만 가져야 한다.`
  - 여기서 말하는 책임이란, **기능** 정도의 의미로 해석하면 된다.
  - 각 클래스가 제공하는 모든 서비스는 단 하나의 기능을 수행하는데 집중돼야 한다는 원칙이다.
- **OCP (Open-Closed Principle) : 개방-폐쇄 원칙**
  - `소프트웨어 모든 구성 요소는 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.`
  - 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계돼야 한다는 원칙이다.
  - 인터페이스를 구현한 새로운 클래스를 만들어서 기능을 구현하는 것이 개방-폐쇄 원칙의 핵심이다.
- **LSP (Liskov Substitution Principle) : 리스코프 치환 원칙**
  - `자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.`
  - 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 올바르게 작동돼야 한다는 원칙이다.
- **ISP (Interface Segregation Principle) : 인터페이스 분리 원칙**
  - `자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다.`
  - 하나의 큰 범용 인터페이스를 구현하기 보다는 특정 클라이언트를 위한 여러 개의 구체적인 인터페이스를 각각 구현하는 것이 낫다는 원칙이다.
- **DIP (Dependency Inversion Principle) : 의존 역전 원칙**
  - `구체화에 의존하지 않고 추상화에 의존해야 한다.`
  - 의존 관계를 맺을 때 변화하기 쉬운 대상 보다는 변화하기 어려운 대상에 의존해야 한다는 원칙이다.
  - 객체 지향적인 관점에서 변화하기 쉬운 대상은 구현 클래스를 의미하고, 변화하기 어려운 대상은 추상 클래스 또는 인터페이스를 의미한다.

### JVM (Java Virtual Machine) Architecture
- **개념**
  - 자바가 특정 운영체제 또는 플랫폼에 종속되지 않고 프로그램을 실행할 수 있도록 도와주는 가상의 OS이다.
- **특징**
  - 자바와 운영체제 사이에서 중개자 역할을 수행하며, 메모리를 관리하고 최적화하는 역할을 담당한다.
  - 자바 컴파일러에 의해 변환된 바이트 코드를 운영체제가 이해할 수 있는 기계어로 바꿔서 실행시켜주는 역할을 담당한다.
- **구성 요소**
  - **Class Loader**
    - JVM 내부로 클래스 파일을 로드하고 링크를 통해 `Runtime Data Area` 영역에 바이트 코드를 배치하는 작업을 수행하는 모듈이다.
    - `jar` 파일 내부에 저장된 클래스들을 JVM 위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제하는 작업을 수행한다.
  - **Execution Engine**
    - **개념**
      - `Runtime Data Area` 영역에 적재된 바이트 코드들을 기계어로 변환해서 명령어 단위로 실행하는 모듈이다.
      - 바이트 코드를 JVM 내부에서 기계가 해석할 수 있는 형태로 변경하기 위해 `Interpreter` 방식과 `JIT` 방식을 사용한다.
    - **실행 방식**
      - **Interpreter**
        - 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
        - 한 줄씩 수행하기 때문에 느리다는 단점이 있다.
      - **JIT(Just-In-Time) Compiler**
        - 인터프리터 방식으로 실행하다가 적절한 시점에 전체 바이트 코드를 컴파일해서 네이티브 코드로 변경한다.
        - 이후에는 인터프리터 방식을 사용하지 않고 네이티브로 컴파일된 코드를 실행하는 것으로 성능을 높이는 방식이다.
        - 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 실행하지만 바이트 코드를 인터프리터 방식으로 실행하는 것보다 훨씬 오래 걸리기 때문에 한 번만 실행되는 코드라면 인터프리터 방식을 사용하는 것이 훨씬 유리하다.
  - **Garbage Collector**
    - `Heap` 메모리 영역에 생성된 객체 중에 참조되지 않는 객체들을 탐색한 후 제거하는 역할을 수행한다.
    - GC가 수행되는 시간은 정확히 알 수 없으며, GC가 수행되는 동안에는 모든 스레드가 일시정지된다.
  - **Runtime Data Area**
    - **Method Area**
    - **Heap Area**
    - **Stack Area**
    - **PC Register**
    - **Native Method Stack**
### 자바 프로그램의 실행 과정

### Java 8 vs Java 11

## 📙 About Java Grammer